#!/usr/bin/python3

import argparse
import json
import os
import subprocess
import sys
from copy import deepcopy
from generator_ctr import GeneratorCfgCtr
from generator_hw import GeneratorCfgHW
from generator_rpc import GeneratorCfgRPC
from generator_sac import GeneratorCfgSAC


class GlobalConfigs:
    # controls script execution
    shall_run_cryptostreams = True   # if true, cryptostreams is run to produce binary files
    shall_submit_experiment = True   # if true, experiment is submitted to RTT
    shall_remove_bins = True         # if true, binary files generated by cryptostreams are removed after submission

    rtt_paper_prefix = 'notset'   # string for easier identification of experiments in RTT results
    cs_seed = '1fe40505e131963c'      # used seed for PRNG


class ExperimentGenerator:
    rtt_submit_experiment_path = '/usr/local/sbin/'
    rtt_configs_path = '../sample_configs/'

    # commands required to submit experiments to RTT are stored into single file (in case of rerun needed)
    rtt_submit_script_path = 'submit_experiments_all.sh'

    generator_cfg = None
    global_cfg = None
    rtt_submit_script_file = None

    def __init__(self, gen_cfg, global_cfg):
        self.generator_cfg = gen_cfg
        self.global_cfg = global_cfg

    def run_single(self, args):
        project, fun, rounds, tv_size, data, num_tv, generator_binary = args

        # pick suitable configuration file for RTT
        cfg_size = ['1MB.json', '10MB.json', '100MB.json', '1000MB.json', 'default-8GB.json']
        if 1000000 <= data < 10000000:
            cfg = cfg_size[0]
        elif 10000000 <= data < 100000000:
            cfg = cfg_size[1]
        elif 100000000 <= data < 1000000000:
            cfg = cfg_size[2]
        elif 1000000000 <= data < 8000000000:
            cfg = cfg_size[3]
        elif 8000000000 <= data:
            cfg = cfg_size[4]
        else:
            exit("Too small data for testing.")
            return None

        # Create human-readable files
        data_length_suffix = '{0}B'.format(data)
        if 1000000 <= data < 1000000000:
            data_length_suffix = '{0}MiB'.format(int(data / 1000000))
        elif 1000000000 <= data:
            data_length_suffix = '{0}GiB'.format(int(data / 1000000000))

        # Example: rtt_prefix = 'SECMARGINS_ctr_seed_1fe40505e131963c_10MB_'
        rtt_prefix = '{0}_{1}_seed_{2}_{3}_'.format(self.global_cfg.rtt_paper_prefix,
                                                    self.generator_cfg.cs_input_strategy_prefix,
                                                    self.global_cfg.cs_seed, data_length_suffix)

        cfg_name = self.generator_cfg.prepare_cfg(project, fun, rounds, tv_size, num_tv, self.global_cfg.cs_seed,
                                                  rtt_prefix)
        print("Processing: " + cfg_name)
        cmd = '{} -c={}'.format(generator_binary, cfg_name)

        print("  " + cmd)
        if self.global_cfg.shall_run_cryptostreams:
            print("Executing: " + cmd)
            process = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE)
            process.wait()

        binfile_name = cfg_name.split('.')[0] + '.bin'

        cmd = '{0}submit_experiment --all_batteries -c {4}{1} -f {2} -n {3}{2}'.format(self.rtt_submit_experiment_path,
                                                                                       cfg, binfile_name,
                                                                                       rtt_prefix,
                                                                                       self.rtt_configs_path)
        self.rtt_submit_script_file.write("{0}\n".format(cmd))
        print("  " + cmd)
        if self.global_cfg.shall_submit_experiment:
            print("Executing: " + cmd)
            process = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE)
            process.wait()

        cmd = 'rm {0}'.format(binfile_name)
        print("  " + cmd)
        if self.global_cfg.shall_remove_bins:
            print("Executing: " + cmd)
            process = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE)
            process.wait()

    def single_setup_generator(self, generator_binary, data=None, num_tv=None):
        def _yield_single_setup(funs, project):
            for fun in funs:
                args = funs[fun]
                for rounds_count in args.rounds:
                    if data:
                        data_out = data
                        num_tv_out = data // args.block_size
                    else:
                        data_out = num_tv * args.block_size
                        num_tv_out = num_tv
                    yield [project, fun, rounds_count, args.block_size, data_out, num_tv_out, generator_binary]

        yield from _yield_single_setup(self.generator_cfg.stream_cipher_funs, 'stream_cipher')
        yield from _yield_single_setup(self.generator_cfg.hash_funs, 'hash')
        yield from _yield_single_setup(self.generator_cfg.block_funs, 'block')

    def run_all(self, binary, data=None, num_tv=None):
        self.rtt_submit_script_file = open(self.rtt_submit_script_path, 'w')

        for single_setup in self.single_setup_generator(binary, data, num_tv):
            self.run_single(single_setup)

        self.rtt_submit_script_file.close()

    def get_tv_size(self, main_args):
        if main_args.stream_type == "stream_cipher":
            return stream_cipher_funs[main_args.fun].block_size
        if main_args.stream_type == "hash":
            return hash_funs[main_args.fun].block_size
        if main_args.stream_type == "block":
            return block[main_args.fun].block_size
        return 16

    def main_args_to_fnc(self, main_args):
        project = main_args.stream_type
        fun = main_args.fun
        rounds = main_args.rounds

        tv_size = get_tv_size(main_args)
        tv_num = (main_args.num // tv_size) if main_args.data else main_args.num

        prepare_cfg(project, fun, rounds, tv_size, tv_num, self.global_cfg.cs_seed)

    def run(self):
        parser = argparse.ArgumentParser()
        self.single_execution_args(parser)
        parser.add_argument(
            '-a',
            '--all',
            action='store_true',
            default=False,
            help='Whether we should execute all experiments, or just single one'
        )
        parser.add_argument(
            '-p',
            '--path_to_generator_binary',
            type=str,
            default='./generator',
            help='Path to the binary of generator (or newly called eacirc_streams binary)'
        )
        group = parser.add_mutually_exclusive_group()
        group.add_argument(
            '-n',
            '--num_tv',
            action='store_true',
            default=False,
            help='Number of test vectors generated'
        )
        group.add_argument(
            '-d',
            '--data',
            action='store_true',
            default=False,
            help='Number of generated bytes'
        )
        parser.add_argument(
            'num',
            metavar='N',
            type=int,
            default=1000000,
            help='the number of TV or data')
        main_args, _ = parser.parse_known_args()

        if main_args.num_tv == main_args.data:
            sys.exit('Choose EITHER --num_tv or --data')

        if main_args.all:
            print('Running all experiments')
            data = main_args.num if main_args.data else None
            num_tv = main_args.num if main_args.num_tv else None
            if data == 0:
                data = self.global_cfg.data_length
                print('### INFO: using data length as provided in global configuration: ' + str(data))
            else:
                print('### INFO: using data length as provided on command line: ' + str(data))

            self.run_all(main_args.path_to_generator_binary, data=data, num_tv=num_tv)
        else:
            self.single_execution_parse(main_args)
            self.main_args_to_fnc(main_args)
            os.system(main_args.path_to_generator_binary)

    def single_execution_parse(self, main_args):
        if main_args.stream_type == '':
            if main_args.fun in stream_cipher_funs:
                main_args.stream_type = 'stream_cipher'
            elif main_args.fun in hash_funs:
                main_args.stream_type = 'hash'
            elif main_args.fun in block_funs:
                main_args.stream_type = 'block'
            else:
                sys.exit('Unknown function and unspecified stream. Set -s! Function was: ' + main_args.fun)
        else:
            if main_args.fun in stream_cipher_funs and main_args.stream_type != 'stream-cipher':
                sys.exit('Mismatch arguments: function '
                         + main_args.fun
                         + ' is from stream-cipher, your stream_type is '
                         + main_args.stream_type)
            elif main_args.fun in hash_funs and main_args.stream_type != 'hash':
                sys.exit('Mismatch arguments: function '
                         + main_args.fun
                         + ' is from hash, your stream_type is '
                         + main_args.stream_type)
            elif main_args.fun in block_funs and main_args.stream_type != 'block':
                sys.exit('Mismatch arguments: function '
                         + main_args.fun
                         + ' is from block, your stream_type is '
                         + main_args.stream_type)
        print('generator.py: preparing config for function '
              + main_args.fun
              + ' from '
              + main_args.stream_type
              + ' reduced to '
              + str(main_args.rounds)
              + ' rounds.')

    def single_execution_args(self, parser):
        parser.add_argument(
            '-s',
            '--stream_type',
            type=str,
            default='',
            help='Stream: for AES, DES... = block, Salsa... = stream-cipher, Keccak... = hash'
        )
        parser.add_argument(
            '-f',
            '--fun',
            type=str,
            default='PRNG',
            help='Function used for data generation'
        )
        parser.add_argument(
            '-r',
            '--rounds',
            type=int,
            default=1,
            help='Function is reduced to --rounds'
        )


def main():
    #data_lengths = [10000000, 100000000, 8000000000]
    data_lengths = [10000000, 100000000]
    for data_len in data_lengths:
        global_cfg = GlobalConfigs()
        global_cfg.rtt_paper_prefix = 'SECMARGINPAPER1'
        global_cfg.data_length = data_len
        ExperimentGenerator(GeneratorCfgCtr(), global_cfg).run()
        ExperimentGenerator(GeneratorCfgHW(), global_cfg).run()
        ExperimentGenerator(GeneratorCfgRPC(), global_cfg).run()
        ExperimentGenerator(GeneratorCfgSAC(), global_cfg).run()

if __name__ == '__main__':
    main()
